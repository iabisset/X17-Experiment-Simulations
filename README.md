# X17-Experiment-Simulations

This repository contains the simulation code for the UdeM X17 done over the course of my Senior Design project and the summer afterwards. This text document summarizes all the folders contained in this repository, but more information can be found in the individual folders and code comments. Each folder contains a directory for the source code and a directory containing the program compiled from the source code. To run the software, one must have an installation of geant4 on their system with appropriate data libraries for decay physics, gamma levels, etc. If there are any questions, please contact me at iain.bisset1@gmail.com

# Preliminary Simulations

This folder contains some basic simulations done at the beginning of the project to familiarize myself with the basics of generating geometries, setting up particle events, and running the software. I have left this in in case any future individuals who take over the project need familiarizing with Geant. The data from the simulations is sent to a text file which is compiled into a histogram of energy depositions by a mathematica file. If anyone taking over this project is familiar with root or a c++ library for plotting then this could be done more efficiently, but for the sake of saving time learning new software I went with what I knew here. Check out the built in examples included in a standard geant4 installation as well, which are the basis for these simulations.

# Geometry

This folder contains the implementation of the experimental geometry supplied to me by UdeM. The geometries were supplied to me in the form of solidworks files. After some time spent looking into various methods of using these geometries in the context of geant4 (including considering simply implementing approximations by hand natively in geant4), I ended up exporting the solidworks files as stl files and using a converter from https://github.com/tihonav/cad-to-geant4-converter to convert the stl files to geant4's markup language format. These files are then parsed and used directly in the program. 

# Backscattering

One specific aspect of the experiment that I simulated was the fraction of electrons that backscatter from specific detector materials. A simulation was set up in which electrons are fired at a material and a semi-sphere region surrounding the incident surface is used to pick up any electrons that backscatter. The fraction of electrons that backscatter is determined for two different detector materials (polystyrene and cesium iodide). It was found that backscattering is negligible for polystyrene, while about 14% backscatter off of cesium iodide.

# Coincidence and X17 implementation

This section deals with implementing Be8 decay, including internal pair creation (IPC) and the hypothetical X17 boson, as well as simulating detections of angular correlation and energy depositions in the final experiment. To ensure the models used by geant4 are accurate, some time was spent researching the accuracy of various physicslist modules in the appropriate energy range of this experiment. I settled on using a modified version of the QBBC physics list which used Livermore E&M physics rather than the standard geant4 E&M models. This simulation uses the 18-scintillator geometry set up from the Geometry folder discussed above.

Be8 decays are implemented using in-built geant4 radioactive decay modules with Be8 set in the 18.15 MeV excited state. Geant4 does not have in-built IPC decay, so these only decay via normal gamma emission. Decay via IPC is accomplished manually using angular correlations of pair formation calculated by Rose (10.1103/PhysRev.76.678). A mathematica file is used to generate random energy divisions between the positron and electron, from which a density function of possible emission angles is generated. The angle between the positron and electron is a random variate of the generated density function. This is done for a large number of events, with the energies and angles written to a text file. Geant4 then reads this text file and uses it to generate IPC events at a rate of 3.9x10^(-3). 

Implementation of the hypothetical boson took some time, as I tried several methods. At first, I attempted to create an entirely new particle definition, program a decay channel for the new particle, and let geant4 handle the energy division and angle between the positron and electron. This proved to be very involved with no deifinitive promise that geant4 would even handle the decay properly once it is implemented. I settled on hard-coding the angular distribution using equation 3 in the Feng et. al. paper found at https://arxiv.org/pdf/1608.03591.pdf . A mathematica file is used to generate the energy divisions and angles, which are then read by the geant4 simulation and used to generate boson decays at a rate of 5.8x10^(-6).

The simulation works by tracking energy depositions in each of the 18 scintillators event-by-event and storing the data in text files. The positions of electron and positron hits on the DAPHNE chamber are recorded and used in post-processing to calculate the angle between the electron and positron in each event. A mathematica file is used to process the data and generate histograms of detected angular correlations, gating on disparity paramater values with a magnitude less than 0.5 . 

One concern in the experiment that was addressed in this simulation is the effect of external pair creation on the measured angular distribution, given the presence of a carbon tube between the decays and the DAPHNE chamber. Doing an analysis in the simulation shows only about 0.65% of detected electron-positron pairs come from pair creation sources other than IPC. 

# Note on bugs

One relatively time-consuming problem that arose in the course of this project is an effect the imported geometries have on the simulation. When markup language geometries are used, the simulation slows down considerably after about 930000 events are simulated. Since millions of events are needed to collect a sizeable number of e+/e- hits, this proved to be a problem. After a long process of debugging, I managed to track the problem down to the way geant4 handles the gdml geometries. I initially thought the slow down was due to large memeory usage due to the size of the gdml files, but reducing the gdml file size by half made no difference. This problem seems inherent to how geant4 handles gdml geometries, so I designed a workaround. This simulation must be run several times at 900000 events per run. The data will accumulate in the text files, after which the post processing is done in mathematica.
